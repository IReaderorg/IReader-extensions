"""
V5 Code Generator - Smart Kotlin Generation
Uses extracted selectors to generate working code
"""

from typing import Dict, List, Set
from dataclasses import dataclass

@dataclass
class SelectorMapping:
    """Maps selectors to their purpose"""
    list_container: str = ".book-item"
    list_title: str = ".title"
    list_cover: str = "img"
    list_link: str = "a"
    
    detail_title: str = ".name h1"
    detail_cover: str = ".img-cover img"
    detail_author: str = ".author"
    detail_summary: str = ".summary"
    detail_genres: str = ".genres"
    detail_status: str = ".status"
    
    chapter_container: str = "li"
    chapter_title: str = ".chapter-title"
    chapter_link: str = "a"
    
    content_container: str = ".chapter__content"

class CodeGeneratorV5:
    """Smart code generator using extracted selectors"""
    
    def __init__(self, metadata: Dict):
        self.metadata = metadata
        self.selectors = self._map_selectors()
        
    def _map_selectors(self) -> SelectorMapping:
        """Map extracted selectors to their purposes"""
        mapping = SelectorMapping()
        all_selectors = self.metadata.get('all_selectors', [])
        methods = self.metadata.get('methods', {})
        
        # Map list selectors (from popularNovels/parseNovels)
        list_methods = ['popularNovels', 'parseNovels', 'searchNovels']
        for method_name in list_methods:
            if method_name in methods:
                selectors = methods[method_name].get('selectors', [])
                for sel in selectors:
                    if 'book' in sel.lower() or 'item' in sel.lower() or 'novel' in sel.lower():
                        mapping.list_container = sel
                    elif 'title' in sel.lower() and 'chapter' not in sel.lower():
                        mapping.list_title = sel
                    elif sel == 'img' or 'cover' in sel.lower():
                        mapping.list_cover = sel
        
        # Map detail selectors (from parseNovel)
        if 'parseNovel' in methods:
            selectors = methods['parseNovel'].get('selectors', [])
            for sel in selectors:
                if 'h1' in sel or ('name' in sel and 'title' not in sel.lower()):
                    mapping.detail_title = sel
                elif 'cover' in sel.lower() and 'img' in sel:
                    mapping.detail_cover = sel
                elif 'author' in sel.lower():
                    mapping.detail_author = sel
                elif 'summary' in sel.lower() or 'description' in sel.lower():
                    mapping.detail_summary = sel
                elif 'genre' in sel.lower():
                    mapping.detail_genres = sel
                elif 'status' in sel.lower():
                    mapping.detail_status = sel
        
        # Map chapter selectors
        chapter_methods = ['parseChapter', 'getChapters']
        for method_name in chapter_methods:
            if method_name in methods:
                selectors = methods[method_name].get('selectors', [])
                for sel in selectors:
                    if 'chapter' in sel.lower() and ('content' in sel.lower() or 'body' in sel.lower()):
                        mapping.content_container = sel
                    elif 'chapter' in sel.lower() and 'title' in sel.lower():
                        mapping.chapter_title = sel
                    elif sel == 'li' or 'chapter-item' in sel.lower():
                        mapping.chapter_container = sel
        
        return mapping
    
    def generate(self, package_name: str, class_name: str, generated_id: int, lang: str) -> str:
        """Generate complete Kotlin code"""
        plugin_type = self.metadata.get('plugin_type', 'scraping')
        
        if plugin_type == 'api':
            return self._generate_api_plugin(package_name, class_name, generated_id, lang)
        else:
            return self._generate_scraping_plugin(package_name, class_name, generated_id, lang)
    
    def _generate_scraping_plugin(self, package_name: str, class_name: str, generated_id: int, lang: str) -> str:
        """Generate scraping-based plugin with actual implementations"""
        
        return f'''package {package_name}

// Generated by Converter V5 - Smart Code Generation
// Selectors: {len(self.metadata.get('all_selectors', []))} extracted
// Methods: {len(self.metadata.get('methods', {}))} analyzed

import io.ktor.client.request.*
import io.ktor.http.*
import ireader.core.source.*
import ireader.core.source.model.*
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element
import tachiyomix.annotations.Extension

@Extension
abstract class {class_name}(private val deps: Dependencies) : ParsedHttpSource(deps) {{

    override val name = "{self.metadata['name']}"
    override val id: Long = {generated_id}L
    override val baseUrl = "{self.metadata['site'].rstrip('/')}"
    override val lang = "{lang}"

    companion object {{
        private const val USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    }}

{self._generate_filters()}

{self._generate_listings()}

{self._generate_browse_methods()}

{self._generate_list_parsing()}

{self._generate_detail_parsing()}

{self._generate_chapter_methods()}

{self._generate_content_methods()}

{self._generate_headers()}
}}
'''
    
    def _generate_filters(self) -> str:
        return '''    // MARK: - Filters
    override fun getFilters(): FilterList {
        return listOf(
            Filter.Title(),
            Filter.Sort(
                "Sort By:",
                arrayOf("Latest", "Popular", "Updated")
            ),
        )
    }'''
    
    def _generate_listings(self) -> str:
        return '''
    // MARK: - Listings
    override fun getListings(): List<Listing> {
        return listOf(
            LatestListing(),
            PopularListing()
        )
    }

    class LatestListing : Listing("Latest")
    class PopularListing : Listing("Popular")'''
    
    def _generate_browse_methods(self) -> str:
        return f'''
    // MARK: - Browse
    override suspend fun getMangaList(sort: Listing?, page: Int): MangasPageInfo {{
        return getLatest(page)
    }}

    override suspend fun getMangaList(filters: FilterList, page: Int): MangasPageInfo {{
        val query = filters.findInstance<Filter.Title>()?.value
        
        if (!query.isNullOrBlank()) {{
            return getSearch(query, page)
        }}
        
        val sortIndex = filters.findInstance<Filter.Sort>()?.value?.index
        return when (sortIndex) {{
            0 -> getLatest(page)
            1 -> getPopular(page)
            else -> getLatest(page)
        }}
    }}

    suspend fun getLatest(page: Int): MangasPageInfo {{
        val url = "$baseUrl/latest?page=$page"
        val doc = client.get(requestBuilder(url)).asJsoup()
        
        return bookListParse(
            doc,
            "{self.selectors.list_container}",
            ".pagination .next"
        ) {{ bookFromElement(it) }}
    }}

    suspend fun getPopular(page: Int): MangasPageInfo {{
        val url = "$baseUrl/popular?page=$page"
        val doc = client.get(requestBuilder(url)).asJsoup()
        
        return bookListParse(
            doc,
            "{self.selectors.list_container}",
            ".pagination .next"
        ) {{ bookFromElement(it) }}
    }}

    suspend fun getSearch(query: String, page: Int): MangasPageInfo {{
        val url = "$baseUrl/search?q=$query&page=$page"
        val doc = client.get(requestBuilder(url)).asJsoup()
        
        return bookListParse(
            doc,
            "{self.selectors.list_container}",
            null
        ) {{ bookFromElement(it) }}
    }}'''
    
    def _generate_list_parsing(self) -> str:
        # Escape quotes in selectors
        title_sel = self.selectors.list_title.replace('"', '\\"')
        link_sel = self.selectors.list_link.replace('"', '\\"')
        cover_sel = self.selectors.list_cover.replace('"', '\\"')
        
        return f'''
    // MARK: - List Parsing
    fun bookFromElement(element: Element): MangaInfo {{
        val title = element.select("{title_sel}").text()
        val url = element.select("{link_sel}").attr("href")
        val cover = element.select("{cover_sel}").attr("src")
        
        return MangaInfo(
            key = if (url.startsWith("http")) url else baseUrl + url,
            title = title,
            cover = if (cover.startsWith("http")) cover else baseUrl + cover
        )
    }}'''
    
    def _generate_detail_parsing(self) -> str:
        # Escape quotes in selectors
        title_sel = self.selectors.detail_title.replace('"', '\\"')
        cover_sel = self.selectors.detail_cover.replace('"', '\\"')
        author_sel = self.selectors.detail_author.replace('"', '\\"')
        summary_sel = self.selectors.detail_summary.replace('"', '\\"')
        genres_sel = self.selectors.detail_genres.replace('"', '\\"')
        status_sel = self.selectors.detail_status.replace('"', '\\"')
        
        return f'''
    // MARK: - Details
    override fun detailParse(document: Document): MangaInfo {{
        val title = document.select("{title_sel}").text().trim()
        val cover = document.select("{cover_sel}").attr("src")
        val author = document.select("{author_sel}").text()
        val description = document.select("{summary_sel}").text().trim()
        val genres = document.select("{genres_sel}").eachText()
        val statusText = document.select("{status_sel}").text()

        return MangaInfo(
            title = title,
            cover = if (cover.startsWith("http")) cover else baseUrl + cover,
            description = description,
            author = author,
            genres = genres,
            status = parseStatus(statusText),
            key = ""
        )
    }}

    private fun parseStatus(status: String): Long {{
        return when {{
            status.contains("Ongoing", ignoreCase = true) -> MangaInfo.ONGOING
            status.contains("Completed", ignoreCase = true) -> MangaInfo.COMPLETED
            status.contains("Complete", ignoreCase = true) -> MangaInfo.COMPLETED
            else -> MangaInfo.UNKNOWN
        }}
    }}'''
    
    def _generate_chapter_methods(self) -> str:
        return f'''
    // MARK: - Chapters
    override fun chaptersSelector(): String {{
        return "{self.selectors.chapter_container}"
    }}

    override fun chapterFromElement(element: Element): ChapterInfo {{
        val link = element.select("{self.selectors.list_link}").attr("href")
        val name = element.select("{self.selectors.chapter_title}").text().trim()

        return ChapterInfo(
            name = name,
            key = if (link.startsWith("http")) link else baseUrl + link
        )
    }}

    override suspend fun getChapterList(
        manga: MangaInfo,
        commands: List<Command<*>>
    ): List<ChapterInfo> {{
        val doc = client.get(requestBuilder(manga.key)).asJsoup()
        val chapters = chaptersParse(doc)
        return chapters.reversed()
    }}'''
    
    def _generate_content_methods(self) -> str:
        return f'''
    // MARK: - Content
    override fun pageContentParse(document: Document): List<String> {{
        // Remove unwanted elements
        document.select("#listen-chapter, #google_translate_element, .ads").remove()
        
        return document.select("{self.selectors.content_container} p").eachText()
    }}

    override suspend fun getContents(chapter: ChapterInfo): List<String> {{
        val doc = client.get(requestBuilder(chapter.key)).asJsoup()
        return pageContentParse(doc)
    }}'''
    
    def _generate_headers(self) -> str:
        return '''
    // MARK: - Headers
    override fun HttpRequestBuilder.headersBuilder(block: HeadersBuilder.() -> Unit) {
        headers {
            append(HttpHeaders.UserAgent, USER_AGENT)
            append(HttpHeaders.CacheControl, "max-age=0")
            append(HttpHeaders.Referrer, baseUrl)
            block()
        }
    }'''
    
    def _generate_api_plugin(self, package_name: str, class_name: str, generated_id: int, lang: str) -> str:
        """Generate API-based plugin"""
        api_endpoints = self.metadata.get('api_endpoints', [])
        
        return f'''package {package_name}

// Generated by Converter V5 - API Plugin
// Endpoints: {len(api_endpoints)} found

import io.ktor.client.request.*
import io.ktor.http.*
import ireader.core.source.*
import ireader.core.source.model.*
import kotlinx.serialization.*
import kotlinx.serialization.json.*
import tachiyomix.annotations.Extension

@Extension
abstract class {class_name}(private val deps: Dependencies) : HttpSource(deps) {{

    override val name = "{self.metadata['name']}"
    override val id: Long = {generated_id}L
    override val baseUrl = "{self.metadata['site'].rstrip('/')}"
    override val lang = "{lang}"

    private val json = Json {{
        ignoreUnknownKeys = true
        isLenient = true
    }}

    // API Endpoints:
{chr(10).join(f"    // - {ep}" for ep in api_endpoints[:10])}

    // TODO: Implement API methods
    // Define data classes for JSON responses
    // Implement getMangaList, parseNovel, getChapterList, getContents
}}
'''
