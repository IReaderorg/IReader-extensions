import com.android.build.gradle.internal.api.BaseVariantOutputImpl
import com.android.build.gradle.tasks.ManifestProcessorTask
import com.android.build.gradle.tasks.ProcessMultiApkApplicationManifest
import groovy.util.Node
import groovy.util.NodeList
import groovy.xml.XmlNodePrinter
import groovy.xml.XmlParser
import org.gradle.api.GradleException
import java.io.File
import java.util.Locale

/*
    Copyright (C) 2018 The Tachiyomi Open Source Project

    This Source Code Form is subject to the terms of the Mozilla Public
    file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

fun BaseVariantOutputImpl.processManifestForExtension(extension: Extension) {
    processManifestProvider.configure {
        doLast {
            processExtension(extension)
        }
    }
}

private fun ManifestProcessorTask.processExtension(extension: Extension) {
    this as ProcessMultiApkApplicationManifest
    val outputDirectory = multiApkManifestOutputDirectory.get().asFile
    val manifestFile = File(outputDirectory, "AndroidManifest.xml")

    if (!manifestFile.exists()) {
        throw GradleException("Can't find manifest file for ${extension.name}")
    }

    val extClass = "tachiyomix.extension.Extension" // This class is generated by ksp
    val parser = XmlParser().parse(manifestFile)

    // Replace the package name
    parser.attributes()["package"] = extension.applicationId

    val app = (parser["application"] as NodeList).first() as Node

    // Icon is set in base AndroidManifest.xml with tools:replace to handle merge conflicts
    // The minimal 67-byte icon is in extensions/res/mipmap-mdpi/
    
    // Update source.icon metadata with the correct URL for remote icons
    if (extension.icon == DEFAULT_ICON || extension.icon.startsWith("http")) {
        // Find and update the source.icon meta-data node
        val metaDataNodes = app.children().filterIsInstance<Node>()
        val iconMetaData = metaDataNodes.find { node ->
            node.name().toString().contains("meta-data") &&
            node.attribute("{http://schemas.android.com/apk/res/android}name") == "source.icon"
        }
        if (iconMetaData != null) {
            // Update the value to the remote icon URL
            val iconUrl = if (extension.icon == DEFAULT_ICON) {
                createExtensionIconLink(extension)
            } else {
                extension.icon
            }
            iconMetaData.attributes()["{http://schemas.android.com/apk/res/android}value"] = iconUrl
        }
    }

    // Add source class metadata
    Node(
        app, "meta-data",
        mapOf(
            "android:name" to "source.class",
            "android:value" to extClass
        )
    )

    // Add deeplinks if needed
    addDeepLinks(app, extension.deepLinks)

    XmlNodePrinter(manifestFile.printWriter()).print(parser)
}

private fun addDeepLinks(app: Node, deeplinks: List<DeepLink>) {
    if (deeplinks.isEmpty()) return

    val activity = Node(
        app, "activity",
        mapOf(
            "android:name" to "tachiyomix.deeplink.SourceDeepLinkActivity",
            "android:exported" to "true",
            "android:theme" to "@android:style/Theme.NoDisplay"
        )
    )

    val filter = Node(activity, "intent-filter")
    Node(filter, "action", mapOf("android:name" to "android.intent.action.VIEW"))
    Node(filter, "category", mapOf("android:name" to "android.intent.category.DEFAULT"))
    Node(filter, "category", mapOf("android:name" to "android.intent.category.BROWSABLE"))

    deeplinks.forEach { link ->
        val data = mutableMapOf<String, String>()
        if (link.scheme.isNotEmpty()) {
            data["android:scheme"] = link.scheme
        }
        if (link.host.isNotEmpty()) {
            data["android:host"] = link.host
        }
        if (link.pathPattern.isNotEmpty()) {
            data["android:pathPattern"] = link.pathPattern
        }
        if (link.path.isNotEmpty()) {
            data["android:path"] = link.path
        }

        Node(filter, "data", data)
    }
}

fun String.isAssetType() : Boolean {
   return this.isNotBlank() && this != DEFAULT_ICON && !this.startsWith("http")
}

const val DEFAULT_ICON = "default_icon"
const val REPO_URL = "https://raw.githubusercontent.com/IReaderorg/IReader-extensions/repov2/icon"

fun createExtensionIconLink(extension: Extension): String {
    return "$REPO_URL/ireader-${extension.lang}-${
        extension.name.toLowerCase(Locale.getDefault())
    }-v${extension.libVersion}.${extension.versionCode}.png"
}
