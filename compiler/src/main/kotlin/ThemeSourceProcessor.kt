/*
 * Copyright (C) IReader Project
 * SPDX-License-Identifier: Apache-2.0
 */

package tachiyomix.compiler

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * KSP Processor for generating theme-based source extensions.
 *
 * Processes @MadaraSource and @ThemeSource annotations to generate
 * source classes that extend theme base classes.
 *
 * @MadaraSource generates a complete Madara-based source with zero code.
 * @ThemeSource generates a source extending any specified theme class.
 */
class ThemeSourceProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    private val processedClasses = mutableSetOf<String>()

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val madaraSources = resolver.getSymbolsWithAnnotation(MADARA_SOURCE_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
            .toList()

        madaraSources.forEach { config ->
            val key = config.qualifiedName?.asString() ?: return@forEach
            if (key !in processedClasses) {
                processedClasses.add(key)
                generateMadaraSource(config)
            }
        }

        val themeSources = resolver.getSymbolsWithAnnotation(THEME_SOURCE_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
            .toList()

        themeSources.forEach { config ->
            val key = config.qualifiedName?.asString() ?: return@forEach
            if (key !in processedClasses) {
                processedClasses.add(key)
                generateThemeSource(config)
            }
        }

        return emptyList()
    }

    private fun generateMadaraSource(config: KSClassDeclaration) {
        val annotation = config.annotations.find {
            it.shortName.asString() == "MadaraSource"
        } ?: return

        val args = annotation.arguments.associate {
            it.name?.asString() to it.value
        }

        val name = args["name"] as? String ?: return
        val baseUrl = args["baseUrl"] as? String ?: return
        val lang = args["lang"] as? String ?: return
        val id = args["id"] as? Long ?: return
        val novelsPath = args["novelsPath"] as? String ?: "novel"
        val novelPath = args["novelPath"] as? String ?: "novel"
        val chapterPath = args["chapterPath"] as? String ?: "novel"

        val packageName = config.packageName.asString()
        val configName = config.simpleName.asString()
        val className = configName.removeSuffix("Config").ifEmpty { name.replace(" ", "") }

        val madaraClass = ClassName("ireader.madara", "Madara")
        val pathClass = ClassName("ireader.madara", "Path")
        val depsClass = ClassName("ireader.core.source", "Dependencies")
        val extensionAnnotation = ClassName("tachiyomix.annotations", "Extension")

        val superCallCode = CodeBlock.builder()
            .add("deps,\n")
            .add("sourceId = %LL,\n", id)
            .add("key = %S,\n", baseUrl)
            .add("sourceName = %S,\n", name)
            .add("language = %S,\n", lang)
            .add("paths = %T(%S, %S, %S)", pathClass, novelPath, novelsPath, chapterPath)
            .build()

        val classSpec = TypeSpec.classBuilder(className)
            .addAnnotation(extensionAnnotation)
            .addModifiers(KModifier.ABSTRACT)
            .primaryConstructor(
                FunSpec.constructorBuilder()
                    .addParameter("deps", depsClass)
                    .build()
            )
            .superclass(madaraClass)
            .addSuperclassConstructorParameter(superCallCode)
            .build()

        try {
            FileSpec.builder(packageName, className)
                .addType(classSpec)
                .addFileComment("Generated by ThemeSourceProcessor - DO NOT EDIT\n\nSource: $name\nBase URL: $baseUrl\nLanguage: $lang")
                .build()
                .writeTo(codeGenerator, Dependencies(false, config.containingFile!!))

            logger.info("ThemeSourceProcessor: Generated Madara source $className for $name")
        } catch (e: Exception) {
            logger.warn("ThemeSourceProcessor: Could not generate $className: ${e.message}")
        }
    }

    private fun generateThemeSource(config: KSClassDeclaration) {
        val annotation = config.annotations.find {
            it.shortName.asString() == "ThemeSource"
        } ?: return

        val args = annotation.arguments.associate {
            it.name?.asString() to it.value
        }

        val name = args["name"] as? String ?: return
        val baseUrl = args["baseUrl"] as? String ?: return
        val lang = args["lang"] as? String ?: return
        val id = args["id"] as? Long ?: return
        val theme = args["theme"] as? String ?: return

        val packageName = config.packageName.asString()
        val configName = config.simpleName.asString()
        val className = configName.removeSuffix("Config").ifEmpty { name.replace(" ", "") }

        val themePackage = theme.substringBeforeLast(".")
        val themeClass = theme.substringAfterLast(".")
        val themeClassName = ClassName(themePackage, themeClass)

        val depsClass = ClassName("ireader.core.source", "Dependencies")
        val extensionAnnotation = ClassName("tachiyomix.annotations", "Extension")

        val classSpec = TypeSpec.classBuilder(className)
            .addAnnotation(extensionAnnotation)
            .addModifiers(KModifier.ABSTRACT)
            .primaryConstructor(
                FunSpec.constructorBuilder()
                    .addParameter("deps", depsClass)
                    .build()
            )
            .superclass(themeClassName)
            .addSuperclassConstructorParameter("deps")
            .addProperty(
                PropertySpec.builder("id", Long::class, KModifier.OVERRIDE)
                    .initializer("%LL", id)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("name", String::class, KModifier.OVERRIDE)
                    .initializer("%S", name)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("lang", String::class, KModifier.OVERRIDE)
                    .initializer("%S", lang)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("baseUrl", String::class, KModifier.OVERRIDE)
                    .initializer("%S", baseUrl)
                    .build()
            )
            .build()

        try {
            FileSpec.builder(packageName, className)
                .addType(classSpec)
                .addFileComment("Generated by ThemeSourceProcessor - DO NOT EDIT\n\nSource: $name\nBase URL: $baseUrl\nLanguage: $lang\nTheme: $theme")
                .build()
                .writeTo(codeGenerator, Dependencies(false, config.containingFile!!))

            logger.info("ThemeSourceProcessor: Generated theme source $className for $name")
        } catch (e: Exception) {
            logger.warn("ThemeSourceProcessor: Could not generate $className: ${e.message}")
        }
    }

    companion object {
        const val MADARA_SOURCE_ANNOTATION = "tachiyomix.annotations.MadaraSource"
        const val THEME_SOURCE_ANNOTATION = "tachiyomix.annotations.ThemeSource"
    }
}

class ThemeSourceProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return ThemeSourceProcessor(
            environment.codeGenerator,
            environment.logger,
            environment.options
        )
    }
}
