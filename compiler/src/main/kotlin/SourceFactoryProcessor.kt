package tachiyomix.compiler

import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.processing.SymbolProcessorProvider
import com.google.devtools.ksp.symbol.KSAnnotated
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.ksp.writeTo

/**
 * KSP Processor that generates SourceFactory implementations from annotations.
 * 
 * This allows defining sources declaratively using annotations like:
 * - @ExploreFetcher for listing endpoints
 * - @DetailSelectors for detail page parsing
 * - @ChapterSelectors for chapter list parsing
 * - @ContentSelectors for content parsing
 */
class SourceFactoryProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        // Find classes with @ExploreFetcher annotations
        val sourcesWithFetchers = resolver.getSymbolsWithAnnotation(EXPLORE_FETCHER_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.validate() }
            .distinctBy { it.qualifiedName?.asString() }
            .toList()

        sourcesWithFetchers.forEach { generateExploreFetchers(it) }

        // Find classes with @SourceFilters
        val sourcesWithFilters = resolver.getSymbolsWithAnnotation(SOURCE_FILTERS_ANNOTATION)
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.validate() }
            .toList()

        sourcesWithFilters.forEach { generateFilters(it) }

        return emptyList()
    }

    private fun generateExploreFetchers(source: KSClassDeclaration) {
        val fetcherAnnotations = source.annotations.filter { 
            it.shortName.asString() == "ExploreFetcher" 
        }.toList()

        if (fetcherAnnotations.isEmpty()) return

        val packageName = source.packageName.asString()
        val className = source.simpleName.asString()
        val generatedClassName = "${className}Fetchers"

        val fetchers = fetcherAnnotations.map { ann ->
            val args = ann.arguments.associate { it.name?.asString() to it.value }
            ExploreFetcherConfig(
                name = args["name"] as String,
                endpoint = args["endpoint"] as String,
                selector = args["selector"] as String,
                nameSelector = args["nameSelector"] as? String ?: "",
                linkSelector = args["linkSelector"] as? String ?: "",
                coverSelector = args["coverSelector"] as? String ?: "",
                isSearch = args["isSearch"] as? Boolean ?: false
            )
        }

        val baseExploreFetcherClass = ClassName("ireader.core.source", "SourceFactory", "BaseExploreFetcher")
        val typeClass = ClassName("ireader.core.source", "SourceFactory", "Type")
        val listType = List::class.asClassName().parameterizedBy(baseExploreFetcherClass)

        val fetcherListCode = fetchers.mapIndexed { index, fetcher ->
            val typeValue = if (fetcher.isSearch) "Type.Search" else "Type.Listing"
            """
            BaseExploreFetcher(
                key = "${fetcher.name}",
                endpoint = "${fetcher.endpoint}",
                selector = "${fetcher.selector}",
                nameSelector = "${fetcher.nameSelector}",
                linkSelector = "${fetcher.linkSelector}",
                coverSelector = "${fetcher.coverSelector}",
                type = $typeValue
            )
            """.trimIndent()
        }.joinToString(",\n")

        val propertySpec = PropertySpec.builder("generatedExploreFetchers", listType)
            .initializer("listOf(\n$fetcherListCode\n)")
            .build()

        val objectSpec = TypeSpec.objectBuilder(generatedClassName)
            .addProperty(propertySpec)
            .addKdoc("Generated explore fetchers for $className")
            .build()

        FileSpec.builder(packageName, generatedClassName)
            .addType(objectSpec)
            .addFileComment("Generated by SourceFactoryProcessor - DO NOT EDIT")
            .build()
            .writeTo(codeGenerator, Dependencies(false, source.containingFile!!))

        logger.info("Generated explore fetchers for $className: ${fetchers.size} fetchers")
    }

    private fun generateFilters(source: KSClassDeclaration) {
        val filterAnnotation = source.annotations.find { 
            it.shortName.asString() == "SourceFilters" 
        } ?: return

        val args = filterAnnotation.arguments.associate { it.name?.asString() to it.value }
        
        val hasTitle = args["hasTitle"] as? Boolean ?: true
        val hasAuthor = args["hasAuthor"] as? Boolean ?: false
        val hasGenre = args["hasGenre"] as? Boolean ?: false
        val hasStatus = args["hasStatus"] as? Boolean ?: false
        val hasSort = args["hasSort"] as? Boolean ?: false
        val sortOptions = (args["sortOptions"] as? List<*>)?.filterIsInstance<String>() ?: emptyList()

        val packageName = source.packageName.asString()
        val className = source.simpleName.asString()
        val generatedClassName = "${className}Filters"

        val filterClass = ClassName("ireader.core.source.model", "Filter")
        val filterListClass = ClassName("ireader.core.source.model", "FilterList")

        val filters = mutableListOf<String>()
        if (hasTitle) filters.add("Filter.Title()")
        if (hasAuthor) filters.add("Filter.Author()")
        if (hasGenre) filters.add("Filter.Genre()")
        if (hasStatus) filters.add("Filter.Status()")
        if (hasSort && sortOptions.isNotEmpty()) {
            val sortOptionsStr = sortOptions.joinToString(", ") { "\"$it\"" }
            filters.add("Filter.Sort(\"Sort By:\", arrayOf($sortOptionsStr))")
        }

        val filtersCode = filters.joinToString(",\n    ")

        val funSpec = FunSpec.builder("getGeneratedFilters")
            .returns(filterListClass)
            .addStatement("return listOf(\n    $filtersCode\n)")
            .build()

        val objectSpec = TypeSpec.objectBuilder(generatedClassName)
            .addFunction(funSpec)
            .addKdoc("Generated filters for $className")
            .build()

        FileSpec.builder(packageName, generatedClassName)
            .addType(objectSpec)
            .addFileComment("Generated by SourceFactoryProcessor - DO NOT EDIT")
            .build()
            .writeTo(codeGenerator, Dependencies(false, source.containingFile!!))

        logger.info("Generated filters for $className")
    }

    private data class ExploreFetcherConfig(
        val name: String,
        val endpoint: String,
        val selector: String,
        val nameSelector: String,
        val linkSelector: String,
        val coverSelector: String,
        val isSearch: Boolean
    )

    companion object {
        const val EXPLORE_FETCHER_ANNOTATION = "tachiyomix.annotations.ExploreFetcher"
        const val SOURCE_FILTERS_ANNOTATION = "tachiyomix.annotations.SourceFilters"
    }
}

class SourceFactoryProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return SourceFactoryProcessor(
            environment.codeGenerator,
            environment.logger,
            environment.options
        )
    }
}
