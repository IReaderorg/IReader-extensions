package ireader.testserver

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import java.io.File

/**
 * Scans the sources directory to discover available sources without loading them.
 * This provides metadata about all sources that can be tested.
 */
class SourceScanner {
    
    private val json = Json { ignoreUnknownKeys = true }
    
    companion object {
        /**
         * Finds the sources directory by checking multiple possible locations.
         */
        fun findSourcesDir(): File {
            val possiblePaths = listOf(
                "sources",                    // If running from project root
                "../sources",                 // If running from source-test-server
                "../../sources",              // If running from deeper directory
            )
            
            for (path in possiblePaths) {
                val dir = File(path)
                if (dir.exists() && dir.isDirectory) {
                    // Verify it's the right sources directory by checking for language subdirs
                    if (dir.listFiles()?.any { it.isDirectory && it.name.length == 2 } == true) {
                        return dir
                    }
                }
            }
            
            // Default to "sources" even if not found
            return File("sources")
        }
    }
    
    /**
     * Scans for all available sources and returns their metadata.
     * This reads from source-index.json files generated by KSP.
     */
    fun scanAvailableSources(sourcesDir: File = findSourcesDir()): List<AvailableSource> {
        if (!sourcesDir.exists()) {
            return emptyList()
        }
        
        val sources = mutableListOf<AvailableSource>()
        
        // Find all source-index.json files
        sourcesDir.walkTopDown().maxDepth(10).forEach { file ->
            if (file.name == "source-index.json" && 
                file.parentFile.name == "resources" &&
                file.parentFile.parentFile.name.contains("Debug")) {
                
                try {
                    val content = file.readText()
                    val jsonArray = json.parseToJsonElement(content).jsonArray
                    
                    jsonArray.forEach { element ->
                        val obj = element.jsonObject
                        val name = obj["name"]?.jsonPrimitive?.content ?: return@forEach
                        val lang = obj["lang"]?.jsonPrimitive?.content ?: "en"
                        val id = obj["id"]?.jsonPrimitive?.content?.toLongOrNull() ?: return@forEach
                        val baseUrl = obj["baseUrl"]?.jsonPrimitive?.content ?: ""
                        val nsfw = obj["nsfw"]?.jsonPrimitive?.content?.toBooleanStrictOrNull() ?: false
                        
                        // Determine the source path
                        val buildDir = file.parentFile.parentFile.parentFile.parentFile.parentFile
                        val sourcePath = buildDir.parentFile.relativeTo(sourcesDir).path
                        
                        sources.add(AvailableSource(
                            name = name,
                            lang = lang,
                            id = id,
                            baseUrl = baseUrl,
                            nsfw = nsfw,
                            path = sourcePath,
                            hasCompiledClasses = hasCompiledClasses(buildDir)
                        ))
                    }
                } catch (e: Exception) {
                    // Skip invalid files
                }
            }
        }
        
        return sources.distinctBy { it.id }
    }
    
    /**
     * Scans source Kotlin files to extract metadata without KSP compilation.
     * This is useful for sources that haven't been compiled yet.
     */
    fun scanSourceFiles(sourcesDir: File = findSourcesDir()): List<SourceFileInfo> {
        if (!sourcesDir.exists()) {
            return emptyList()
        }
        
        val sourceFiles = mutableListOf<SourceFileInfo>()
        
        // Find all Kotlin source files
        sourcesDir.walkTopDown().forEach { file ->
            if (file.extension == "kt" && 
                file.parentFile.name.startsWith("ireader") &&
                !file.name.contains("Test") &&
                !file.name.contains("Generated")) {
                
                try {
                    val content = file.readText()
                    
                    // Check if it's a source file (has @Extension annotation)
                    if (content.contains("@Extension") || content.contains("@MadaraSource")) {
                        val info = parseSourceFile(file, content)
                        if (info != null) {
                            sourceFiles.add(info)
                        }
                    }
                } catch (e: Exception) {
                    // Skip unreadable files
                }
            }
        }
        
        return sourceFiles
    }
    
    private fun parseSourceFile(file: File, content: String): SourceFileInfo? {
        // Extract source name from class declaration
        val classMatch = Regex("""(?:abstract\s+)?class\s+(\w+)""").find(content)
        val className = classMatch?.groupValues?.get(1) ?: return null
        
        // Extract name from override val name
        val nameMatch = Regex("""override\s+val\s+name\s*[=:]\s*["']([^"']+)["']""").find(content)
        val name = nameMatch?.groupValues?.get(1) ?: className
        
        // Extract baseUrl
        val baseUrlMatch = Regex("""override\s+val\s+baseUrl\s*[=:]\s*["']([^"']+)["']""").find(content)
        val baseUrl = baseUrlMatch?.groupValues?.get(1) ?: ""
        
        // Extract lang
        val langMatch = Regex("""override\s+val\s+lang\s*[=:]\s*["']([^"']+)["']""").find(content)
        val lang = langMatch?.groupValues?.get(1) ?: "en"
        
        // Check for @MadaraSource annotation
        val madaraMatch = Regex("""@MadaraSource\s*\([^)]*name\s*=\s*["']([^"']+)["'][^)]*\)""").find(content)
        val isMadara = madaraMatch != null
        val madaraName = madaraMatch?.groupValues?.get(1)
        
        // Determine source type
        val sourceType = when {
            isMadara -> "MadaraSource"
            content.contains("SourceFactory") -> "SourceFactory"
            content.contains("ParsedHttpSource") -> "ParsedHttpSource"
            else -> "Unknown"
        }
        
        return SourceFileInfo(
            name = madaraName ?: name,
            className = className,
            lang = lang,
            baseUrl = baseUrl,
            sourceType = sourceType,
            filePath = file.path,
            packageName = extractPackageName(content)
        )
    }
    
    private fun extractPackageName(content: String): String {
        val match = Regex("""package\s+([\w.]+)""").find(content)
        return match?.groupValues?.get(1) ?: ""
    }
    
    private fun hasCompiledClasses(buildDir: File): Boolean {
        val classesDir = File(buildDir, "tmp/kotlin-classes")
        return classesDir.exists() && classesDir.walkTopDown().any { it.extension == "class" }
    }
}

@Serializable
data class AvailableSource(
    val name: String,
    val lang: String,
    val id: Long,
    val baseUrl: String,
    val nsfw: Boolean,
    val path: String,
    val hasCompiledClasses: Boolean
)

@Serializable
data class SourceFileInfo(
    val name: String,
    val className: String,
    val lang: String,
    val baseUrl: String,
    val sourceType: String,
    val filePath: String,
    val packageName: String
)
